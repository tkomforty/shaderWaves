<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>3D Seascape - Subtle Splashes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <script>
      
        // Modified with subtle splashes and small particle effects

        let canvas, gl;
        let program;
        let startTime = Date.now();
        let mouse = { x: 0, y: 0 };
        let splashes = []; // Array to hold multiple splashes
        const MAX_SPLASHES = 15; // More splashes for better reactivity
        
        // Initialize WebGL
        window.onload = function() {
            // Create canvas
            canvas = document.createElement('canvas');
            document.body.appendChild(canvas);
            
            // Set canvas to fullscreen
            resize();
            
            // Get WebGL context
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                alert('WebGL not supported');
                return;
            }
            
            // Create shader program
            program = createProgram(gl, vertexShader, fragmentShader);
            
            // Create a simple quad
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                 1, -1,
                -1,  1,
                 1,  1
            ]), gl.STATIC_DRAW);
            
            // Get attribute location
            const positionLocation = gl.getAttribLocation(program, 'aPosition');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            
            // Add event listeners
// Add event listeners for both mouse and touch
window.addEventListener('resize', resize);

// Mouse events
window.addEventListener('mousemove', updateMouse);
window.addEventListener('mousedown', handleClick);

// Touch events for mobile
canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Initialize empty splashes array
            for (let i = 0; i < MAX_SPLASHES; i++) {
                splashes.push({ 
                    active: 0, 
                    worldX: 0, 
                    worldZ: 0, 
                    time: 0,
                    strength: 0,   // Random strength factor
                    particleCount: 0 // Number of particles
                });
            }
            
            // Start animation
            animate();
        };
        
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function updateMouse(e) {
            mouse.x = e.clientX / canvas.width;
            mouse.y = 1.0 - e.clientY / canvas.height;
        }
        
        // Convert screen coordinates to world position
// Convert screen coordinates to world position
function screenToWorld(screenX, screenY, camZ) {
    // Handle touch events that pass the whole event
    if (screenX.clientX !== undefined) {
        screenY = screenX.clientY;
        screenX = screenX.clientX;
    }
    
    // Rest of the function remains the same
    const aspectRatio = canvas.width / canvas.height;
    const x = ((screenX / canvas.width) * 2.0 - 1.0) * aspectRatio;
    const y = ((canvas.height - screenY) / canvas.height) * 2.0 - 1.0;
    
    // Camera parameters
    const cameraHeight = 5.0;
    
    // Create ray direction (with fixed camera angle)
    let dirX = x;
    let dirY = -2.0; // Forward direction
    let dirZ = y;
    
    // Normalize the direction
    const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
    const normDirX = dirX / length;
    const normDirY = dirY / length;
    const normDirZ = dirZ / length;
    
    // Intersect with y=0 plane (ocean surface)
    const t = -cameraHeight / normDirZ;
    
    // Calculate intersection point in world space
    const worldX = 0 + normDirX * t;
    const worldZ = camZ + normDirY * t;
    
    return { x: worldX, z: worldZ };
}
        
        function handleClick(e) {
            // Current time in seconds
            const now = (Date.now() - startTime) / 1000.0;
            
            // Current camera Z position
            const camZ = now * 2.0;
            
            // Convert screen coordinates to world coordinates
            const worldPos = screenToWorld(e.clientX, e.clientY, camZ);
            
            // Find an empty slot or replace the oldest splash
            let oldestIndex = 0;
            let oldestTime = Infinity;
            
            for (let i = 0; i < MAX_SPLASHES; i++) {
                if (splashes[i].active === 0) {
                    oldestIndex = i;
                    break;
                }
                if (splashes[i].time < oldestTime) {
                    oldestTime = splashes[i].time;
                    oldestIndex = i;
                }
            }
            
            // Generate random values for variation
            const strength = 0.3 + Math.random() * 0.3; // 0.3-0.6 strength factor (much smaller)
            const particleCount = 3 + Math.floor(Math.random() * 5); // 3-7 particles (fewer)
            
            // Store world position of the splash
            splashes[oldestIndex] = {
                active: 1,
                worldX: worldPos.x,
                worldZ: worldPos.z,
                time: now,
                strength: strength,
                particleCount: particleCount
            };
        }
      
      
      let touchActive = false;
let lastTouchTime = 0;

// Handle touch events
function handleTouchStart(e) {
    e.preventDefault();
    touchActive = true;
    
    // Update mouse position based on touch
    if (e.touches.length > 0) {
        updateTouch(e.touches[0]);
        handleClick(e.touches[0]);
    }
}

function handleTouchMove(e) {
    e.preventDefault();
    
    // Update mouse position based on touch
    if (e.touches.length > 0) {
        updateTouch(e.touches[0]);
        
        // Create ripples when dragging with a minimum time interval
        const now = (Date.now() - startTime) / 1000.0;
        if (now - lastTouchTime > 0.1) {
            handleClick(e.touches[0]);
            lastTouchTime = now;
        }
    }
}

function handleTouchEnd(e) {
    e.preventDefault();
    touchActive = false;
}

function updateTouch(touch) {
    mouse.x = touch.clientX / canvas.width;
    mouse.y = 1.0 - touch.clientY / canvas.height;
}
        
        function animate() {
            // Get current time in seconds
            const time = (Date.now() - startTime) / 1000.0;
            
            // Update splash states - deactivate old splashes
            for (let i = 0; i < MAX_SPLASHES; i++) {
                if (splashes[i].active === 1) {
                    const age = time - splashes[i].time;
                    if (age > 10) { // Shorter splash duration for more subtle effects
                        splashes[i].active = 0;
                    }
                }
            }
            
            // Clear canvas
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Use shader program
            gl.useProgram(program);
            
            // Set shared uniforms
            gl.uniform1f(gl.getUniformLocation(program, 'iTime'), time);
            gl.uniform2f(gl.getUniformLocation(program, 'iResolution'), canvas.width, canvas.height);
            gl.uniform2f(gl.getUniformLocation(program, 'iMouse'), mouse.x * 2.0 - 1.0, mouse.y * 2.0 - 1.0);
            
            // Set all splash uniforms
            for (let i = 0; i < MAX_SPLASHES; i++) {
                const splashLocation = gl.getUniformLocation(program, 'iSplashes[' + i + ']');
                gl.uniform4f(splashLocation, 
                    splashes[i].worldX, 
                    splashes[i].worldZ, 
                    splashes[i].active === 1 ? splashes[i].time : 0.0,
                    splashes[i].active
                );
                
                // Set splash properties
                const propsLocation = gl.getUniformLocation(program, 'iSplashProps[' + i + ']');
                gl.uniform3f(propsLocation,
                    splashes[i].strength,
                    splashes[i].particleCount,
                    0.0 // Reserved for future use
                );
            }
            
            // Draw quad
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 8);
            
            // Request next frame
            requestAnimationFrame(animate);
        }
        
        function createProgram(gl, vertSource, fragSource) {
            const vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertSource);
            gl.compileShader(vertShader);
            
            const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragSource);
            gl.compileShader(fragShader);
            
            // Check for shader compile errors
            if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
                console.error('Vertex shader compilation error:', gl.getShaderInfoLog(vertShader));
            }
            if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
                console.error('Fragment shader compilation error:', gl.getShaderInfoLog(fragShader));
            }
            
            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            
            // Check for linking errors
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program linking error:', gl.getProgramInfoLog(program));
            }
            
            return program;
        }
        
        // Simple vertex shader
        const vertexShader = `
            attribute vec2 aPosition;
            
            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;
        
        // 3D Seascape fragment shader
        const fragmentShader = `
            precision highp float;
            
            uniform vec2 iResolution;
            uniform float iTime;
            uniform vec2 iMouse;
            uniform vec4 iSplashes[15]; // worldX, worldZ, time, active
            uniform vec3 iSplashProps[15]; // strength, particleCount, reserved
            
            // Constants
            const int NUM_STEPS = 6;
            const float PI = 3.14159265359;
            const float EPSILON = 1e-3;
            
            // Sea parameters
            const int ITER_GEOMETRY = 3;
            const int ITER_FRAGMENT = 5;
            const float SEA_HEIGHT = 0.86;
            const float SEA_CHOPPY = 4.0;
            const float SEA_SPEED = 0.8;
            const float SEA_FREQ = 0.16;
            const vec3 SEA_BASE = vec3(0.0, 0.09, 0.18);
            const vec3 SEA_WATER_COLOR = vec3(0.48, 0.54, 0.5);
            
            // Matrix for octaves
            mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);
            
            // Math utilities
            mat3 fromEuler(vec3 ang) {
                vec2 a1 = vec2(sin(ang.x), cos(ang.x));
                vec2 a2 = vec2(sin(ang.y), cos(ang.y));
                vec2 a3 = vec2(sin(ang.z), cos(ang.z));
                mat3 m;
                m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x, a1.y*a2.x*a3.x+a3.y*a1.x, -a2.y*a3.x);
                m[1] = vec3(-a2.y*a1.x, a1.y*a2.y, a2.x);
                m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x, a1.x*a3.x-a1.y*a3.y*a2.x, a2.y*a3.y);
                return m;
            }
            
            float hash(vec2 p) {
                float h = dot(p, vec2(127.1, 311.7));    
                return fract(sin(h) * 43758.5453123);
            }
            
            float hash(vec3 p) {
                p = fract(p * vec3(0.1031, 0.1030, 0.073));
                p += dot(p, p.yxz + 33.33);
                return fract((p.x + p.y) * p.z);
            }
            
            float noise(in vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);    
                vec2 u = f*f*(3.0-2.0*f);
                return -1.0+2.0*mix(
                    mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), u.x),
                    mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), u.x), 
                    u.y
                );
            }
            
            // Lighting
            float diffuse(vec3 n, vec3 l, float p) {
                return pow(dot(n, l) * 0.4 + 0.6, p);
            }
            
            float specular(vec3 n, vec3 l, vec3 e, float s) {    
                float nrm = (s + 8.0) / (PI * 8.0);
                return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;
            }
            
            // Sky
            vec3 getSkyColor(vec3 e) {
                e.y = max(e.y, 0.50);
                vec3 ret;
                ret.x = pow(1.0-e.y, 20.0);
                ret.y = 1.0-e.y;
                ret.z = 0.6+(1.0-e.y)*0.4;
                return ret;
            }
            
            // Sea
            float sea_octave(vec2 uv, float choppy) {
                uv += noise(uv);        
                vec2 wv = 1.0-abs(sin(uv));
                vec2 swv = abs(cos(uv));    
                wv = mix(wv, swv, wv);
                return pow(1.0-pow(wv.x * wv.y, 0.5), choppy);
            }
            
            // Particle rendering - much more subtle
            bool renderParticle(vec3 p, vec3 rayOrigin, vec3 rayDir, vec4 splashData, vec3 props) {
                if (splashData.w <= 0.0) return false;
                
                float clickAge = iTime - splashData.z;
                if (clickAge > 10.5) return false; // Shorter lifetime
                
                vec2 splashCenter = vec2(splashData.x, splashData.y);
                float strength = props.x;
                int particleCount = int(props.y);
                
                // Only process particles when ray is close to splash location
                float distance2D = length(p.xz - splashCenter);
                if (distance2D > 55.0) return false; // Smaller radius for optimization
                
                // Check all potential particles based on splash properties
                for (int i = 0; i < 50; i++) {
                    if (i >= particleCount) break;
                    
                    // Particle properties based on its index
                    float particleId = float(i) / float(particleCount);
                    float angle = particleId * PI * 12.0;
                    float radialDistance = (1.0 + hash(vec3(splashData.x, splashData.y, float(i))) * 2.0) * strength;
                    
                    // Particle trajectory - much smaller
                    float gravity = 9.8;
                    float initialVelocity = 30.0 * strength; // Lower initial velocity
                    float particleAngle = PI/4.0 + hash(vec3(angle, splashData.z, float(i))) * PI/4.0;
                    
                    // Calculate height based on projectile motion
                    float vY = initialVelocity * sin(particleAngle);
                    float height = vY * clickAge - 0.5 * gravity * clickAge * clickAge;
                    
                    // Only show particles while they're above water
                    if (height < 0.0) continue;
                    
                    // Calculate position based on time
                    float vX = initialVelocity * cos(particleAngle) * cos(angle);
                    float vZ = initialVelocity * cos(particleAngle) * sin(angle);
                    
                    vec3 particlePos = vec3(
                        splashData.x + vX * clickAge,
                        height,
                        splashData.y + vZ * clickAge
                    );
                    
                    // Particle size (very small)
                    float size = 0.1 * (1.0 - clickAge / 1.5) * strength;
                    
                    // Check if ray hits particle
                    vec3 oc = rayOrigin - particlePos;
                    float b = dot(oc, rayDir);
                    float c = dot(oc, oc) - size * size;
                    float h = b * b - c;
                    
                    if (h > 0.0) {
                        // Ray hits this particle!
                        return true;
                    }
                }
                
                return false;
            }
            
            // Calculate subtle splash effect
            float calculateSplash(vec3 p, vec4 splashData, vec3 props) {
                if (splashData.w <= 0.0) return 0.0; // Inactive splash
                
                float clickAge = iTime - splashData.z;
                if (clickAge > 11.5) return 0.0; // Shorter lifetime
                
                // Get splash properties
                float strength = props.x; // Much smaller strength factor
                
                // Splash world position (fixed in world space)
                vec2 splashPos = vec2(splashData.x, splashData.y);
                
                // Distance from current point to splash
                float dist = length(p.xz - splashPos);
                
                // Central water column - Very small and subtle
                float column = 0.0;
                if (clickAge < 0.3) {
                    float columnHeight = 5.0 * strength * (1.0 - clickAge / 0.3);
                    column = columnHeight * exp(-dist * 8.0); // Very narrow column
                }
                
                // Main splash peak - Smaller, quicker
                float peakPhase = clickAge * 2.0; // Faster
                float peakRadius = peakPhase * 2.5; // Smaller radius
                
                float peak = 0.0;
                if (peakPhase < 1.0) {
                    float amp = 4.0 * strength * (1.0 - peakPhase / 1.0);
                    float width = 1.0 + peakPhase * 0.3;
                    peak = amp * exp(-pow(dist - peakRadius, 2.0) / width);
                }
                
                // Expanding ring waves - Small, subtle
                float ringsPhase = max(0.0, clickAge - 0.1);
                float primaryRing = 3.0 * strength * exp(-ringsPhase * 1.0) * 
                                   exp(-pow(dist - ringsPhase * 5.0, 2.0) / 2.0);
                
                // Fine ripple details - Subtle
                float ripplePhase = max(0.0, clickAge - 0.05);
                float ripples = 1.0 * strength * exp(-ripplePhase * 0.8) * 
                               sin(dist * 3.0 - ripplePhase * 15.0) * 
                               exp(-dist * 0.52) * 
                               max(0.0, 1.0 - ripplePhase / 1.5);
                
                // Very subtle crater
                float crater = 0.0;
                float craterPhase = clickAge * 1.5; 
                if (craterPhase < 0.7) {
                    float craterRadius = 0.50 + craterPhase * 1.0;
                    float innerRadius = max(0.2, craterRadius - 0.8);
                    
                    float craterShape = smoothstep(0.0, innerRadius, dist) * 
                                       (1.0 - smoothstep(innerRadius, craterRadius, dist));
                    
                    crater = -2.0 * strength * craterShape * (1.0 - craterPhase / 0.7);
                }
                
                // Combine all effects
                return column + peak + primaryRing + ripples + crater;
            }
            
            float map(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                
                float d, h = 0.0;    
                for(int i = 0; i < ITER_GEOMETRY; i++) {        
                    d = sea_octave((uv+iTime*SEA_SPEED)*freq, choppy);
                    d += sea_octave((uv-iTime*SEA_SPEED)*freq, choppy);
                    h += d * amp;        
                    uv *= octave_m; freq *= 1.9; amp *= 0.22;
                    choppy = mix(choppy, 1.0, 0.2);
                }
                
                // Process all active splashes at their fixed world positions
                for (int i = 0; i < 15; i++) {
                    if (iSplashes[i].w > 0.0) {
                        float splash = calculateSplash(p, iSplashes[i], iSplashProps[i]);
                        h += splash;
                    }
                }
                
                return p.y - h;
            }
            
            float map_detailed(vec3 p) {
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75;
                
                float d, h = 0.0;    
                for(int i = 0; i < ITER_FRAGMENT; i++) {        
                    d = sea_octave((uv+iTime*SEA_SPEED)*freq, choppy);
                    d += sea_octave((uv-iTime*SEA_SPEED)*freq, choppy);
                    h += d * amp;        
                    uv *= octave_m; freq *= 1.9; amp *= 0.22;
                    choppy = mix(choppy, 1.0, 0.2);
                }
                
                // Process all active splashes at their fixed world positions
                for (int i = 0; i < 15; i++) {
                    if (iSplashes[i].w > 0.0) {
                        float splash = calculateSplash(p, iSplashes[i], iSplashProps[i]);
                        h += splash;
                    }
                }
                
                return p.y - h;
            }
            
            vec3 getNormal(vec3 p, float eps) {
                vec3 n;
                n.y = map_detailed(p);    
                n.x = map_detailed(vec3(p.x+eps, p.y, p.z)) - n.y;
                n.z = map_detailed(vec3(p.x, p.y, p.z+eps)) - n.y;
                n.y = eps;
                return normalize(n);
            }
            
            float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  
                float tm = 0.0;
                float tx = 1000.0;    
                float hx = map(ori + dir * tx);
                if(hx > 0.0) return tx;   
                float hm = map(ori + dir * tm);    
                float tmid = 0.0;
                for(int i = 0; i < NUM_STEPS; i++) {
                    tmid = mix(tm, tx, hm/(hm-hx));                   
                    p = ori + dir * tmid;                   
                    float hmid = map(p);
                    if(hmid < 0.0) {
                        tx = tmid;
                        hx = hmid;
                    } else {
                        tm = tmid;
                        hm = hmid;
                    }
                }
                return tmid;
            }
            
            vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  
                float fresnel = 1.0 - max(dot(n, -eye), 0.0);
                fresnel = pow(fresnel, 3.0) * 0.65;
                    
                vec3 reflected = getSkyColor(reflect(eye, n));    
                vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12; 
                
                vec3 color = mix(refracted, reflected, fresnel);
                
                float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);
                color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;
                
                // Add foam on wave/splash peaks (more subtle)
                float foam = smoothstep(3.0, 8.0, p.y);
                color = mix(color, vec3(1.0), foam);
                
                // Add specular highlights
                color += vec3(specular(n, l, eye, 60.0));
                
                return color;
            }
            
            void main() {
                // Normalized pixel coordinates
                vec2 uv = gl_FragCoord.xy / iResolution.xy;
                vec2 p = uv * 2.0 - 1.0;
                p.x *= iResolution.x / iResolution.y;
                
                // Camera & view - FIXED DIRECTION (no mouse influence)
                vec3 ang = vec3(
                    0.0, // No pitch/tilt
                    0.0, // No yaw - fixed forward direction
                    0.0  // No roll
                );
                
                vec3 ori = vec3(
                    0.0,
                    5.0, // Camera height
                    iTime * 2.0 // Camera movement along Z axis
                );
                
                vec3 dir = normalize(vec3(p.xy, -2.0));
                dir = normalize(dir) * fromEuler(ang);
                
                // Check for particle hits first
                bool hitParticle = false;
                for (int i = 0; i < 15; i++) {
                    if (iSplashes[i].w > 0.0) {
                        if (renderParticle(ori, ori, dir, iSplashes[i], iSplashProps[i])) {
                            hitParticle = true;
                            break;
                        }
                    }
                }
                
                vec3 color;
                
                if (hitParticle) {
                    // Render white particle/droplet
                    color = vec3(1.0);
                } else {
                    // Raymarch to the ocean
                    vec3 p3d;
                    heightMapTracing(ori, dir, p3d);
                    vec3 dist = p3d - ori;
                    vec3 n = getNormal(p3d, dot(dist, dist) * EPSILON);
                    vec3 light = normalize(vec3(0.0, 1.0, 0.8)); 
                    
                    // Get sea color and mix with sky
                    color = mix(
                        getSkyColor(dir),
                        getSeaColor(p3d, n, light, dir, dist),
                        pow(smoothstep(0.0, -0.02, dir.y), 0.2)
                    );
                    
                    // Post-processing
                    color = pow(color, vec3(0.75));
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
    </script>
</body>
</html>
